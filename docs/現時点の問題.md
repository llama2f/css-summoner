現時点の問題
extracted-annotations.jsonのcomponentTypes. "baseClasses": {
"tooltip": "tooltip-base",
"text": "text-base",
"infobox": "infobox-base",
"img": "img-base",
"heading": "heading-base",
"form": "form-base",
"card": "card-base",
"button": "btn-base",
"badge": "badge-base",
"accordion": "accordion-base"
},
でベースは全て取得できている
しかし
index.jsの
// ベースクラスが見つからないコンポーネントの警告 (構造化後に行う)
const missingBaseClasses = Object.keys(
structuredData.componentTypes
).filter((component) => !structuredData.baseClasses[component])

    		if (missingBaseClasses.length > 0) {
    			const warningMsg = `以下のコンポーネントにベースクラス（variant: base）が見つかりませんでした: ${missingBaseClasses.join(
    				', '
    			)}`
    			// Add to meta errors and also emit PostCSS warning
    			structuredData.meta.errors.push(warningMsg)
    			result.warn(warningMsg, { plugin: PLUGIN_NAME })
    		}

に引っかかりベースが見つからないエラーがログされている

postcss-css-annotations プラグインの設計（Once フックで全データをまとめて処理する想定）と、css-summoner-integration.js での実装（ファイルごとに PostCSS を実行）が根本的にミスマッチしています。これが、すべてのコンポーネントでベースクラスが見つからないというエラーが発生する原因です。

解決策:

postcss-css-annotations プラグイン (src/postcss-annotations/src/index.js) を修正し、ファイルごとの処理に対応させる必要があります。

具体的な修正方針:

プラグインのスコープでデータを保持: プラグインのトップレベルスコープ（module.exports の戻り値のオブジェクト内）に、全ファイルからの抽出データを一時的に蓄積する変数（例: accumulatedData）を定義します。
Once フックを Comment フックに変更: アノテーションコメントの解析と基本的なデータ抽出（component, variant, className など）を Comment フックで行います。抽出した情報は、ルールノードの情報（ruleText, selector など）と合わせて、一時的なオブジェクトとして accumulatedData に追加します。
OnceExit フックを追加: PostCSS の処理がすべて完了した後に呼び出される OnceExit フックを追加します。
OnceExit で最終処理:
accumulatedData に蓄積された全ファイル分の情報を使って structureComponentData 関数を呼び出し、完全な structuredData を生成します。
生成された structuredData を使って、ベースクラスチェックを行います。
最終的な structuredData を含むメッセージを result.messages.push します。
ファイル出力などの後処理を行います。
この修正により、プラグインはファイルごとに呼び出されても、最終的にすべての情報を集約してから処理を行うようになります。
